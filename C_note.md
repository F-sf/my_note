## C

* 大小端：多字节数据的存储方式，高位在前为大端，低位在前为小端，可用共用体(联合体)测试当前机器是何种存储方式。

* 函数指针作为输入参数语法格式：(..., 返回数据类型 (* 形参函数名)(输入参数类型 输入参数1, ...), ...)

* 二进制除法和模二除法的区别：

  > 二进制除法手算时和十进制除法过程相同，列竖式，得余数，减，借位，直至余数小于除数。
  >
  > 而模二除法有一定区别，其不采用减操作而采用异或操作，每次余数均右移一位，首位为1则商为1，否则商为0，直至余数位数小于除数。过程中并没有二进制减法和借位操作，优势是运算时每一位的结果不会影响其他位。

* 二维数组相关：

  > 二维数组数组名a表示数组指针，地址的值和二维数组第一个元素a\[0][0]起始地址相同，但指针的类型为一维数组指针。对其进行解引用\*a之后得到一维数组头指针a[0]，此时值仍为a\[0][0]的起始地址，但指针类型已经变成了数组内容的类型。因此可以通过\*(*(a+i)+j)的方式取a\[i][j]。
  >
  > PS: a[i]操作本质为对a取i的偏移地址，然后对a+i解引用。
  
* 虽然数组名和指向数组第一个元素的指针基本等价(并不完全一致，如作为sizeof()参数时)，但结构体并非如此，结构体变量名并不等价于指向结构体第一个元素的指针，结构体变量调用内部成员时使用`.`，而结构体指针调用内部成员时使用`->`。

* 调用函数时的一种大致流程

  > 将调用前栈顶指针，输入参数，局部变量，调用前CPU寄存器现场等入栈；调用结束后先恢复现场，然后将栈顶指针恢复至调用前栈顶指针，继续流程。
  >
  > 函数调用过程中内存栈区和CPU的动作和中断发生过程很像，但函数调用过程会有输入参数和返回值的机制，而中断过程没有。

* 指针和引用：指针本质上仍是一个数据，一个uint32_t类型的表示地址的变量；而引用更多指一个概念，相对应与拷贝，表示通过指针传递数据，也表示并没有创建一个完全独立的新数据，只是拿取了别处的数据。

* 关键字volatile：直译为易变的，用来修饰变量是为了告诉编译器不要对其进行编译优化。实际作用是每次对该变量的操作直接读取内存地址的数据。

  > 一般在多任务或中断服务函数同时操作某个变量时可使用volatile修饰，防止其因编译优化而出现逻辑外的bug。

## STM32

* flash寿命在10K次擦写左右。

* HCLK为AHB总线提供时钟，一般由SYSCLK不分频得到，SYSCLK通过高速外部时钟HSE经过PLL倍频分频后得到，作为CPU时钟。

*  TIM1、TIM8为高级定时器，TIM6、TIM7为基本定时器，其他为通用定时器。
  * 基本定时器最菜，基本只能用于计数，产生更新中断。
  * 高级定时器是通用定时器的超集，完全可以当通用定时器用。
  
* TIM1、TIM8~TIM11的时钟为APB2时钟的两倍即168M，TIM2~TIM7、TIM12~TIM14的时钟为APB1的时钟的两倍即84M。

* 定时器更新中断中断服务函数中，无论以何种方式退出，切记清除中断标志位，否则程序会一直跑死在中断中。

* 所谓上拉下拉，只有在IO为高阻态时才有意义。具体原理见参考手册中电路。

* 关于内存分配的一些笔记：

  > ​		一般来说，程序的内存会被分为 1. 代码段 2. 已初始化的静态和全局变量段 3. 未初始化的静态和全局变量段 4.常量段 5. 堆(程序员手动申请的内存空间，向上生长) 6. 栈(短生命周期的局部变量，向下生长) 		静态和全局的非常量会存到2,3中；局部的const修饰的变量并不会存到常量区，其性质类似于局部变量，实际对其的处理方式与编译器有关；而局部的static const修饰的变量会存到常量区而不是静态区。		stm32编译时生成Code(1)，RW-data(2)，RO-data(4,只读和常量完全等价)，ZI-data(3)， flash中会存储Code，RO-data，RW-data(ram掉电易失，故需在flash中备份)；ram中会存储RW-data，ZI-data，堆和栈可在.s中设置其大小。

* 全局和静态变量若不进行初始化，在内存中会被自动清零；而局部变量若不进行初始化，可能在栈中会被置为无意义的随机值，故局部变量必须进行初始化。

* STM32不同系列间常用外设对应的IO基本相同，更改芯片时一般更改启动文件，编译环境的Device，宏定义即可。

* 中断和异常发生时寄存器入栈顺序**xPSR->PC->LR->R12->R3->R2->R1->R0**，可以往回倒7个拿到中断发生时下一条执行的程序指令PC，往回倒6个拿到发生中断时正在执行的指令,即中断服务函数返回地址LR。若进入中断后LR = 0xFFFFFFFD则说明之前使用的是PSP，若LR = 0xFFFFFFF9则说明之前使用的堆栈是MSP，可进入堆栈查看中断具体在何处发生。

### 一些常见文件的解释

* stm32fxxx.h: 同系列不同芯片的中断号设置、外设寄存器结构体typedef、外设寄存器地址等。
* system_stm32fxxx.c: SystemInit()，设置SysClk时钟源等。
* startup_stm32f40_41xxx.s: 堆栈大小设置、中断向量表、中断服务函数本体、上电时reset从此文件内某行启动，初始化系统堆栈，调用SystemInit和main