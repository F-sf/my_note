## C

* 大小端：多字节数据的存储方式，高位在前为大端，低位在前为小端，可用共用体(联合体)测试当前机器是何种存储方式。

* 函数指针作为输入参数语法格式：(..., 返回数据类型 (* 形参函数名)(输入参数类型 输入参数1, ...), ...)

* 二进制除法和模二除法的区别：

  > 二进制除法手算时和十进制除法过程相同，列竖式，得余数，减，借位，直至余数小于除数。
  >
  > 而模二除法有一定区别，其不采用减操作而采用异或操作，每次余数均右移一位，首位为1则商为1，否则商为0，直至余数位数小于除数。过程中并没有二进制减法和借位操作，优势是运算时每一位的结果不会影响其他位。

* 二维数组相关：

  > 二维数组数组名a表示数组指针，地址的值和二维数组第一个元素a\[0][0]起始地址相同，但指针的类型为一维数组指针。对其进行解引用\*a之后得到一维数组头指针a[0]，此时值仍为a\[0][0]的起始地址，但指针类型已经变成了数组内容的类型。因此可以通过\*(*(a+i)+j)的方式取a\[i][j]。
  >
  > PS: a[i]操作本质为对a取i的偏移地址，然后对a+i解引用。
  
* 虽然数组名和指向数组第一个元素的指针基本等价(并不完全一致，如作为sizeof()参数时)，但结构体并非如此，结构体变量名并不等价于指向结构体第一个元素的指针，结构体变量调用内部成员时使用`.`，而结构体指针调用内部成员时使用`->`。

* 调用函数时的一种大致流程

  > 将调用前栈顶指针，输入参数，局部变量，调用前CPU寄存器现场等入栈；调用结束后先恢复现场，然后将栈顶指针恢复至调用前栈顶指针，继续流程。
  >
  > 函数调用过程中内存栈区和CPU的动作和中断发生过程很像，但函数调用过程会有输入参数和返回值的机制，而中断过程没有。

## STM32

* flash寿命在10K次擦写左右。

*  TIM1、TIM8为高级定时器，TIM6、TIM7为基本定时器，其他为通用定时器。
  * 基本定时器最菜，基本只能用于计数，产生更新中断。
  * 高级定时器是通用定时器的超集，完全可以当通用定时器用。
  
* TIM1、TIM8~TIM11的时钟为APB2时钟的两倍即168M，TIM2~TIM7、TIM12~TIM14的时钟为APB1的时钟的两倍即84M。

* 定时器更新中断中断服务函数中，无论以何种方式退出，切记清除中断标志位，否则程序会一直跑死在中断中。

* 所谓上拉下拉，只有在IO为高阻态时才有意义。具体原理见参考手册中电路。

* 关于内存分配的一些笔记：

  > ​		一般来说，程序的内存会被分为 1. 代码段 2. 已初始化的静态和全局变量段 3. 未初始化的静态和全局变量段 4.常量段 5. 堆(程序员手动申请的内存空间，向上生长) 6. 栈(短生命周期的局部变量，向下生长) 		静态和全局的非常量会存到2,3中；局部的const修饰的变量并不会存到常量区，其性质类似于局部变量，实际对其的处理方式与编译器有关；而局部的static const修饰的变量会存到常量区而不是静态区。		stm32编译时生成Code(1)，RW-data(2)，RO-data(4,只读和常量完全等价)，ZI-data(3)， flash中会存储Code，RO-data，RW-data(ram掉电易失，故需在flash中备份)；ram中会存储RW-data，ZI-data，堆和栈可在.s中设置其大小。

* 全局和静态变量若不进行初始化，在内存中会被自动清零；而局部变量若不进行初始化，可能在栈中会被置为无意义的随机值，故局部变量必须进行初始化。

